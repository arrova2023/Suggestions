REST API to suggest nearby cities; this is done based on the name of the location, its latitude and longitude.

REST API consumption validation URL:
Type: GET

http://localhost:8080/suggestions?q=london&lat=42.98339&lon=-81.23304


Where in the URL the values:
q = <location name> String
lat = <latitude> Float (>0)
lon = <length> Float(<0)


Where the response generated by said consumption must have a format similar to the following:
[
     {
         "name": "london : America/Toronto",
         "latitude": 42.98339,
         "longitude": -81.23304,
         score: 1.0
     },
     {
         "name": "london : America/New_York",
         "latitude": 39.88645,
         "longitude": -83.44825,
         "score": 0.002552867223175697
     },
     {
         "name": "london : America/New_York",
         "latitude": 37.12898,
         "longitude": -84.08326,
         "score": 0.0014376255204344688
     }
]

Explanation; in each nesting of variables we have the following variables:
"name": Name of the location most closely related to the location entered by the user in the "q" variable in the URL.
latitude
"length" Length
"score": The confidence level indicating whether the location entered by the user is correct or not.

This REST API is used to detect the closest locations with points of interest for a user and works as follows:

There is a database with names of locations and their respective latitude and longitude, thousands of points in Canada and the United States of America, so the service that can be consumed through this REST API is mainly focused on North American users, although it really In this database you can insert the locations with points of interest located throughout the world, in the previous example it is seen how a user who was looking for a location called "london" at the coordinates 42.98339 lon = -81.23304 had totally success in matching his hypothesis (where he allegedly believed the location was) and also found 2 more locations but in different locations and through the scores we see that because the relationship of the location name with the latitude and longitude established by the user does not match other locations, so with this computational model I can automatically learn that the location the user knew is in "Canada", but how do I do all this?

This was done using an algorithm based on 2 features extraction stages, the first stage was performed using the Cosine function and the second stage was performed using the SemiVersine function, the structure of the REST API is explained in detail below:

Taking into account the structure of our bank/database called "cities_canada-usa.tsv" the first stage of feature extraction is:

1.- Cosine:
In this first stage, a Machine Learning technique widely used in the area of Natural Language Processing is used, mainly for the analysis, search and retrieval of information, which is known as "Cosine Similarity", with this measure of similarity the location name entered by the user (variable "q") and behaves with the names of all locations in the database (cities_canada-usa.tsv) and if 1 or more locations with related names (similar or identical) are found ) are retrieved, otherwise nothing is retrieved. At the same time, their respective variables "lat" and "lon" are also recovered, which are transformed by a function in the next stage.

2.- Semiversene
With this last stage, the SermiVerseno formula is used, which taking as a frame of reference "the radius of the earth of 6371kms" uses a function to automatically generate the degree of similarity/difference between the latitude and longitude entered by the user in comparison with the latitude and longitude of the locations that were retrieved in the previous stage (cosine).

The design of this REST API is completely based on a "geometric" approach since to generate a confidence measure (score) 2 concepts are used that are mainly used to generate trigonometric functions, which will be explained below:

1.- Cosine:
The cosine similarity is a measure of the existing similarity between two vectors in a space that has an inner product with which the value of the cosine of the included angle between them is evaluated. This trigonometric function provides a value equal to 1 if the included angle is zero, that is, if both vectors point to the same place. Any angle between the vectors, the cosine would give a value less than one. If the vectors were orthogonal, the cosine would vanish, and if they pointed in the opposite direction, their value would be -1. In this way, the value of this metric is between -1 and 1, that is, in the closed interval [-1,1].

This distance is frequently used in the search and retrieval of information by representing the words (or document) in a vector space. In text mining, cosine similarity is applied in order to establish a similarity metric between texts.2 In data mining, it is usually used as an indicator of text cluster cohesion. Cosine similarity should not be considered as a metric because it does not satisfy the triangle inequality.

Learn more about cosine similarity: https://es.wikipedia.org/wiki/Similitud_coseno#:~:text=El%20Coseno%20Suave%E2%80%8B%20es,similitud%20entre%20pares%20de%20caracter% C3% Statistics.

2.- Semiversene:
The semiverse formula is an important equation for astronomical navigation, in terms of calculating the great circle distance between two points on a globe knowing their longitude and latitude. It is a special case of a more general formula of spherical trigonometry, the law of semiverses, which relates the sides and angles of "spherical triangles".

Learn more about the semiverseno: https://es.wikipedia.org/wiki/F%C3%B3rmula_del_semiverseno

The project directory tree is as follows:

```
    Suggests
    |________ src/main/java
    |______________________ com.example.demo
                            |_______________ CosineSimilartyCalculator.java
                            |_______________ HaversineDistanceCalculator.java
                            |_______________ SuggestionsController.java
                            |_______________ SuggestsApplication.java
                            |_______________ TermFrequencyCalculator.java
    |
    |________ src/main/resources
                       |_______________ cities_canada-usa.tsv
    |
    |________ src/test/java
                            |_______________ com.example.demo
                                             |_______________ SuggestsApplicationTests.java
```

Suggests Application:
Project main class:

TermFrequencyCalculator:
Before generating the Cosine Similarity between the city(q) and the cities of the database.tsv, the corresponding text strings must be transformed into vectors because this calculation cannot be performed on text strings but if they are represented in a numerically this can be done perfectly.

CosineSimilartyCalculator:
Once the names of the cities in question are represented in a vector plane, they can be compared by Cosine Similarity using this class, if cities are found in the .tsv related to the city entered by the user, they are recovered and displayed.

HaversineDistanceCalculator:
Once the related locations are retrieved, the Semiversene or Harversine Distance is generated between the latitude and longitude entered by the user in the URL (value "q") and the latitudes and longitudes of each retrieved location, after that to generate the level of "trust" is ordered in descending order (starting with the one with the greatest similarity to the one with the least similarity), if there is a similarity of 1 (that is, 100%) it means that the location is completely valid and can be trusted that it exists, but the closer it is to 0 means that the location has little probability of being related to the user's intentions and that it is not trusted that said location is the one to be verified.

SuggestionsController:
It is used to load the data bank (cities_canada-usa.tsv) and after that, first execute the Cosine calculation and finally the Semiversene.


cities_canada-usa.tsv:
Data bank with location names, latitude and longitude.

Suggests Application Tests:
Unit tests.